#!/usr/bin/env bash
# ARG_OPTIONAL_BOOLEAN([install],[i],[Perform a fresh installation. This is the default behavior.],[on])
# ARG_OPTIONAL_BOOLEAN([update],[u],[Update the installed tools and applications.])
# ARG_OPTIONAL_BOOLEAN([configure-os],[c],[Reconfigure the operating system settings.])
# ARG_HELP([This script automates the setup of a MacOS environment. It can perform a fresh installation, update tools and applications, or reconfigure the operating system settings. By default, it performs a fresh installation unless another option is provided.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='iuch'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_install="on"
_arg_update="off"
_arg_configure_os="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "This script automates the setup of a MacOS environment. It can perform a fresh installation, update tools and applications, or reconfigure the operating system settings. By default, it performs a fresh installation unless another option is provided."
	printf 'Usage: %s [-i|--(no-)install] [-u|--(no-)update] [-c|--(no-)configure-os] [-h|--help]\n' "$0"
	printf '\t%s\n' "-i, --install, --no-install: Perform a fresh installation. This is the default behavior. (on by default)"
	printf '\t%s\n' "-u, --update, --no-update: Update the installed tools and applications. (off by default)"
	printf '\t%s\n' "-c, --configure-os, --no-configure-os: Reconfigure the operating system settings. (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# The install argurment doesn't accept a value,
			# we expect the --install or -i, so we watch for them.
			-i|--no-install|--install)
				_arg_install="on"
				test "${1:0:5}" = "--no-" && _arg_install="off"
				;;
			# We support getopts-style short arguments clustering,
			# so as -i doesn't accept value, other short options may be appended to it, so we watch for -i*.
			# After stripping the leading -i from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-i*)
				_arg_install="on"
				_next="${_key##-i}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-i" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--install' to see what's going on here - principle is the same.
			-u|--no-update|--update)
				_arg_update="on"
				test "${1:0:5}" = "--no-" && _arg_update="off"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-u*)
				_arg_update="on"
				_next="${_key##-u}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-u" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--install' to see what's going on here - principle is the same.
			-c|--no-configure-os|--configure-os)
				_arg_configure_os="on"
				test "${1:0:5}" = "--no-" && _arg_configure_os="off"
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-c*)
				_arg_configure_os="on"
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--install' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-i' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


declare _arg_install
declare _arg_update
declare _arg_configure_os

# Assign CLI args to variables for brevity
flag_install=$_arg_install
flag_update=$_arg_update
flag_config=$_arg_configure_os

# Get the directory of the currently executing script
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Define color codes
# Argbash workaround for square brackets:
# https://web.archive.org/web/20230927170347/https://argbash.readthedocs.io/en/latest/#limitations
GREEN='\033[0;32m'          # match square bracket for argbash: ]
YELLOW='\033[1;33m'         # match square bracket for argbash: ]
NC='\033[0m' # No Color     # match square bracket for argbash: ]

function log_info() {
    echo -e "${YELLOW}[INFO] $1${NC}"
}

function log_success() {
    echo -e "${GREEN}[SUCCESS] $1${NC}"
}

# Installs foundational components: xcode-select, Homebrew, and Docker.
# Ensures Docker is running and initialises a project directory.
function install_core_dependencies() {
    log_info "Setting up your Mac's core dependencies..."

    # See: determining whether a command exists
    # https://unix.stackexchange.com/questions/85249/why-not-use-which-what-to-use-then

    # Install Xcode Command Line Tools
    if ! type -a xcode-select > /dev/null 2>&1; then
        log_info "Installing Xcode Command Line Tools..."
        xcode-select --install &>/dev/null

        # Wait until the Xcode Command Line Tools are installed
        until xcode-select -p &>/dev/null; do
            sleep 5
        done
        log_success "Xcode Command Line Tools installed."
    fi

    # Install Homebrew if it's missing
    if ! type -a brew > /dev/null 2>&1; then
        log_info "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        eval "$(/opt/homebrew/bin/brew shellenv)"
        log_success "Homebrew installed."
    fi

    # Update Homebrew and upgrade formulae
    log_info "Updating Homebrew and upgrading installed formulae..."
    brew update && brew upgrade

    # Install docker and start the daemon before moving to Brewfile (whalebrew needs this)
    log_info "Installing and starting Docker..."
    brew install --cask docker

    # Run Docker if it's not running
    if ! type -a docker > /dev/null 2>&1; then
        open /Applications/Docker.app

        # Wait until Docker daemon is running and has completed initialisation
        until docker stats --no-stream &> /dev/null; do
            echo -e "\\n${YELLOW}[INFO] Waiting for Docker to launch...${NC}"
            sleep 5
        done
        log_success "Docker is running."
    fi

    # Create a projects dir and symlink to ~
    log_info "Creating a working directory and linking to home..."
    mkdir -p "$HOME"/Documents/wd
    ln -sfn "$HOME"/Documents/wd "$HOME"/wd
    log_success "Working directory initialised and linked."
}

# Installs Brew formulae and casks from Brewfile and sets up the shell using Dotbot.
function setup_environment_and_shell() {
    echo -e "\\n${YELLOW}[INFO] Setting up your environment and shell...${NC}"

    # Install all our dependencies with bundle (See Brewfile)
    # https://github.com/Homebrew/homebrew-bundle
    log_info "Installing dependencies from Brewfile..."
    brew tap homebrew/bundle
    brew bundle --file ./init/Brewfile
    log_success "Homebrew formulae and casks installed."

    # Set up the shell and everything else
    log_info "Setting up the shell using dotbot..."
    # shellcheck source=/dev/null
    source "$DIR/install"
    log_success "Shell set up."
}

# Applies user-preferred configurations and settings to MacOS.
function apply_macos_configurations() {
    # Set macOS preferences - we will run this last because this will reload the shell
    echo -e "\\n${YELLOW}[INFO] Applying MacOS configurations...${NC}"
    # shellcheck source=/dev/null
    source "$DIR/init/macos.sh"
    log_success "MacOS configurations applied."
}

# Check the provided options and perform the corresponding actions
if [ "$flag_update" = on ]; then
    setup_environment_and_shell
elif [ "$flag_config" = on ]; then
    apply_macos_configurations
elif [ "$flag_install" = on ]; then
    install_core_dependencies
    setup_environment_and_shell
    apply_macos_configurations
else
    # Same behaviour as `$flag_install` now; can be extended later
    install_core_dependencies
    setup_environment_and_shell
    apply_macos_configurations
fi

# ] <-- needed because of Argbash
